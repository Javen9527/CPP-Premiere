### 顺序是：拷贝操作（能移动的都能拷贝，为了提升性能而使用移动操作）<- 移动操作 <- 右值引用 <- move（显示将右值引用绑定到左值上） 

### 移动操作的实质有点像浅拷贝 + 处理移动源为销毁无害的状态

### 移动构造函数
* 第一个参数是该类型的右值引用，任何额外参数都必须有默认实参
* 需要完成：资源移动 + 移动源处理（置为销毁无害）

### 移动赋值函数
* 如果类中定义了移动构造函数： HasPtr(HasPtr&& p)noexcept:ps(p.ps){p.ps = nullptr;}
* 此时定义一个移动赋值函数：HasPtr& operator=(Hasptr p){swap(*this, p); return *this;}
* 那么该赋值函数同时具有调用拷贝构造和移动构造的能力：依据传入是左值还是右值确认(拷贝和移动指的是实参到形参的操作)

### 普通成员函数的移动操作
* 普通成员函数也可以提供一个拷贝版本 + 移动版本(拷贝和移动指的是函数体内的操作)
* 拷贝版本：const 的左值引用：void func(const T&);
* 移动版本：非const 的右值引用：void func(T&&);
* 一般而言不需要定义const T&&（既然是移动，则不能是const）版本和T &（既然是拷贝，则源应该是const）版本

### noexcept
* 由于移动操作通常不分配内存，因此通常不会抛出任何异常
* 标准库一般认为移动类对象可能会抛出异常，因此做了一些处理这种异常的额外操作
* 使用：在构造函数的参数列表后括号与初始化列表冒号之间，在赋值函数的参数列表后括号和函数体前大括号之间

### 引用限定符
* 旧标准中可以对右值进行赋值。
* 新标准兼容了旧标准，但是可以通过引用限定符阻止这种用法：指定this只能指向右值或者左值的属性
* 引用限定符只能用于成员函数（非static）且在声明和定义中都需要使用：在函数体和参数列表之间
* 当同时出现const限定符和引用限定符时，要先写const

### 拓展：
* 成员函数有一个隐式参数this，this指向调用该成员函数的对象（即传入对象的地址）
* this是一个常量指针（即 T *const)
* 由于this不是一个指向常量的指针，因此不可以在常量对象上调用普通的成员函数（无法将常量的地址传入非指针常量的this），因此对于常量对象而言，需要将this指定为：const T *const
* 其中这个const就放在函数体和参数列表括号之间

### 总而言之，毕竟能移动的都能拷贝，可以将移动操作理解为利用率拷贝中的浅拷贝（无需分配内存），并为之处理了源对象（保证浅拷贝后没有多个用户指向同一个资源）

