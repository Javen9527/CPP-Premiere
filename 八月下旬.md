#### 类：下面互相组合组成完整的类（拷贝构造、拷贝赋值 + 移动构造、移动赋值）
  - 构造函数 + 赋值(=)运算符
  - 拷贝操作 + 移动操作
  - 析构

#### 左值与右值
  - 左值引用：绑定左值，通过+const可绑定右值
  - 右值引用：绑定右值，通过move可绑定左值

#### 移动与右值：移动操作即：1.接管右值引用指向的内容，2.处理该右值引用（不再被非法引用，或者销毁掉)

#### 仅通过定义一个赋值运算符就实现：拷贝赋值 + 移动赋值.

  ```c++
  // copy-constructor
  YOU(const YOU& you):m_i(new int(*you.m_i)) {cout << "copy constructor" << endl;}

  // move-construtor
  YOU(YOU&& you):m_i(you.m_i) {you.m_i = nullptr; cout << "move constructor" << endl;}

  // copy && move assignment
  YOU& operator=(YOU you) { this->m_i = you.m_i; you.m_i = nullptr; return *this;}
  ```
  注意：上述代码存在问题：对赋值操作进行自赋值检查，以及对左操作数进行内存释放操作
  
#### 模板函数与右值
  - 模板函数参数定义为右值时：讲道理此时该函数只能绑定到一个右值参数上，但实际上它可以绑定到一个左值上。
  ```c++
  template<typename T>
  void foo(T&& t);
  ```
  实现绑定左值的原理即：通过一些既定的规则: 推断出T为左值引用 T&, 在通过引用折叠最终让推断出的类型为左值引用。
  
#### 模板中的右值的使用场景
  - 模板重载
  - 模板转发
  - 其他不建议使用，因为在模板中，可能会将模板参数推断为一个引用类型，导致模板内的代码异常（比如想要赋值却进行了引用绑定T t = val）

#### 关于右值相关函数的重载，需同时如下两个
  - const T& 版本：绑定左值和const右值
  - T&& 版本：绑定非const右值

