//整理C++ Primer中重要的知识点

一、第一章

p5. cerr/clog:写到cerr的数据是不缓冲的，写到clog的数据是被缓冲的

p6. 输入输出运算符的计算结果是左侧的运算对象

p13. 使用io对象作为条件：其效果是检查流的状态

p21. 调用运算符()

二、第二章

p30. C++标准规定了基本内置类型的尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。不同机器上类型大小有所差别

p30. char       -> 基本字符类型，一个char的空间确保了机器基本字符集中的任意字符对应的数值
     wchar_t    -> 扩展字符类型，确保了机器最大扩展字符集中的任意一个字符
     char16_t   -> Unicode字符集
     char32_t   -> Unicode字符集

p30. C++标准对浮点数类型的尺寸规定是：有效数字的位数而不是多少个bit

p32. char只有两种类型：signed char + unsigned char char具体表现为哪种由编译器决定

p33. 浮点数运算尽量选用dobule而不是float

p34. 类型转换：
    ① 赋予一个有符号数超出范围的数值时，其值是未定义的；
    ② 赋予一个无符号数超出范围的数值时，其值是该数值对表示范围取模；
    ③ 浮点数赋予整数类型时，直接取整数部分而不是四舍五入。
    ※ 在有符号和无符号混用的情况下，有符号会转换成无符号类型(对范围取模)

p35. 字面值
    ① 以0开头为八进制
    ② 以0x或者0X开头为16进制
    ③ 默认情况下十进制的字面值带符号，类型是int、long、long long中尺寸最小的那个，八进制和十六进制字面值可能带符号也可能不带符号...
    ④ 字符串字面值和char型字面值的区别：字符串字面值实际是常量字符数组，编译器会在字符串后面添加一个空字符‘\0’
    ⑤ 转义序列：以‘\’开头
    ⑥ 泛化的转义序列：\后面紧跟123个八进制字符 或者 \x后面跟全部十六进制字符

p37. 指定字面值的类型
    ① 前缀：
        u   -> Unicode16字符                -> char16_t
        U   -> Unicode32字符                -> char32_t
        L   -> 宽字符                       -> wchar_t
        u8  -> UTF-8(仅用于字符串字面值常量)   -> char
    ② 后缀：
        u or U      -> unsigned
        l or L      -> long
        f or F      -> float or long double
        ll or LL    -> long long

p38. 指针的字面值：nullptr

p39. 初始化和赋值的区别：初始化是创建一个变量时赋予其初值，赋值是擦除当前值并赋予新值：myClass(int a):m_a(a){} 和 myClass(int a){m_a = a;} 则第一个构造函数更优化

p40. 列表初始化优点：内置类型使用列表初始化时，如果面临丢失信息的风险则编译器会报错

p40. 默认初始化：由变量类型 + 变量位置 决定：内置类型在所有函数体之外被初始化为0，在函数体内则不被初始化（值未定义）

p41. 分离式编译：为了支持分离式编译，c++将声明和定义区分开来。

p41. extern：
    ① 只声明不定义
    ② 如果extern声明时候再显示初始化，则抵消了extern的作用
    ③ 在函数体内部对extern修饰的变量进行初始化则报错
    ④ 想要使用其他文件中的变量：(1)使用.h中的变量：包含头文件 (2)使用.cpp中的变量：使用extern声明

p42. 变量命名规范：对变量用小写 对类用首字母大写

p44. 向全局作用域发出请求：::前面为空

p45. 复合类型：基本数据类型 + 声明符列表

p46. 引用：
    ① 引用不是对象，定义引用必须初始化是因为一旦定义引用则它将和初始值对象一直绑定
    ② 引用不是对象，所以没有引用的引用，也没有指向引用的指针

p47. 指针
    ① 指针本身是一个对象，允许对指针赋值和拷贝
    ② 定义指针无需初始化

p47. 一般而言，指针和引用的类型与其指向的对象类型要严格匹配。特殊情况如：指向常量的指针和引用可以指向常量、非常量、字面值 

p47. 指针类型：
    ① 指向一个对象
    ② 指向一个对象的下一个紧邻位置
    ③ 空指针
    ④ 无效指针（上述之外）

p48. 生成空指针：
    ① 空指针：cstdlib中定义了一个预处理变量：NULL。尽量避免使用NULL
    ② 指针的字面值：nullptr 可转换成任意其他类型的指针
    ③ 使用字面值0来生成空指针

P52. 基本数据类型 + 声明符(类型修饰符+变量)：int *p而不是int* p; 类型修饰符是声明符的一部分，离变量最近的类型修饰符有最直接的影响。

p52. 指向指针的引用（没有指向引用的指针）：int *&p;

p53. const变量一旦创建其值就不能改变，因此const对象必须初始化。该初始化可以发生在运行时，也可发生在编译时。

p54. const变量默认仅文件内有效。对于初始值不是常量表达式的const变量，要想多文件使用，定义和声明都需要使用extern关键字。

p55. 指向常量的引用 const int &p (其实int const& p也可)
    ① 没有引用本身是常量的，因为引用不是对象。
    ② 指向常量的引用是“万能引用”，可以指向常量、非常量、字面值、表达式，且可以使这些量的类型与指向常量的引用的类型不匹配。

p56. 指向常量的指针 const int *p（其实int const* p也可）
    ① 指向常量的指针可以指向一个非常量，但是指向常量的指针的类型必须和指向的变量的类型一致。

p57. 指针本身是一个常量: const离变量最近 int *const p

p57. 顶层和底层const
    ① 对于变量本身是常量的（非指针的普通对象也算），则为顶层const；对于其指向的变量是常量的，则为底层const
    ② 引用不是对象，因此它只有底层const
    ③ 无论顶层和底层，记住一点：非常量可以复制(转换)给常量，常量不可以复制给非常量

p58. 常量表达式：
    ① 值不会改变 + 编译过程就可以得到值（不是运行过程）（结合常量的定义理解p53）
    ② constexpre 类型变量目的：利用函数的优势又想避免函数的缺点（编译过程中展开，免去函数调用的开销）

p60. 类型别名：
    ① typedef 基本数据类型 类型别名
    ② using typeA = typeB 

p61. auto：atuo定义的变量必须有初始值（不然没法推导），且* &是声明符的一部分不是基本数据类型的一部分

p62. decltype：想从表达式结果推断类型但是不想用结果值初始化变量

p68. 预处理器的头文件保护符：
    #ifndef
    #define
    ...
    #endif


